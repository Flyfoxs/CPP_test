#include <bits/stdc++.h>
using namespace std;

// 7172：【AHOI2024初中】计数
// N = 最大长度
// mod = 题目要求取模
const int N = 3005, mod = 1e9 + 7;

// n: 序列长度
// m: 颜色种类数
int n, m;

// f1[i][j]:
// 处理到前 i 个位置
// 当前已经“形成了 j 个可继续匹配的颜色段”
// 且第 i 个位置处于「已匹配/已闭合」状态
int f1[N][N];

// f0[i][j]:
// 处理到前 i 个位置
// 当前已经有 j 个颜色段
// 且第 i 个位置处于「未匹配/未闭合」状态
int f0[N][N];

int main(){
    freopen("d.in", "r", stdin);
    // freopen("d.out", "w", stdout);

    cin >> n >> m;

    // 初始状态：
    // 处理 0 个位置，0 个颜色段
    // 空序列视为一个“已闭合”的合法状态
    f1[0][0] = 1;

    // 枚举当前位置 i（第 i+1 个元素）
    for(int i = 0; i < n; i++)
    {
        // j 表示当前已经使用/打开的颜色段数量
        // 最多不会超过 i
        for(int j = 0; j <= i; j++)
        {
            // ---------------------------
            // 情况 1：
            // 从 f1[i][j] 转移到 f1[i+1][j]
            //
            // 当前是“已闭合”状态
            // 继续选择一个“已经出现过的颜色”
            // 可选的颜色数量 = j
            // 不会增加颜色段数量
            // ---------------------------
            f1[i+1][j] = (f1[i+1][j] + 1LL * f1[i][j] * j) % mod;

            printf("1st f1[%d][%d]=%d, f1[%d][%d]=%d\n",
                   i, j, f1[i][j], i+1, j, f1[i+1][j]);

            // ---------------------------
            // 情况 2：
            // 从 f0[i][j] 转移到 f1[i+1][j]
            //
            // 当前是“未闭合”状态
            // 仍然选一个已存在的颜色（j 种）
            // 使得当前位置完成闭合
            // ---------------------------
            f1[i+1][j] = (f1[i+1][j] + 1LL * f0[i][j] * j) % mod;

            printf("2nd f0[%d][%d]=%d, f1[%d][%d]=%d\n",
                   i, j, f0[i][j], i+1, j, f1[i+1][j]);

            // ---------------------------
            // 情况 3：
            // 从 f1[i][j] 转移到 f0[i+1][j+1]
            //
            // 当前已闭合
            // 新开一个颜色段
            // 可用的新颜色数 = m - j
            // 颜色段数 +1，状态变为未闭合
            // ---------------------------
            f0[i+1][j+1] =
                (f0[i+1][j+1] + 1LL * f1[i][j] * (m - j)) % mod;

            // ---------------------------
            // 情况 4：
            // 从 f0[i][j] 转移到 f0[i+1][j]
            //
            // 当前未闭合
            // 继续使用一个“新颜色”
            // 颜色段数不变
            // ---------------------------
            f0[i+1][j] =
                (f0[i+1][j] + 1LL * f0[i][j] * (m - j)) % mod;
        }
    }

    // 调试输出：最终第 n 位、不同 j 的 f1 状态
    for(int i = 1; i <= n; i++)
    {
        printf("f1[%d][%d]=%d\n", n, i, f1[n][i]);
    }

    // 统计答案：
    // 所有「处理完 n 个位置，且状态为已闭合(f1)」的方案数之和
    int ans = 0;
    for(int i = 1; i <= n; i++)
    {
        ans = (ans + f1[n][i]) % mod;
    }

    cout << ans;  // 输出答案
    return 0;
}

/**
 g++-14 -o main.out main.cpp && ./main.out
 */
